# 디자인 패턴
## GoF(Gang of Four) 디자인 패턴
1. 생성 패턴
```
객체를 생성하는 것과 관련된 패턴

Abstraction factory
- 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴 , 관련된 서브 클래스를 한번에 교체 가능

Builder 
-작게 분리된 인스턴스를 조립하듯 객체 생성

Factory Method
- 객체를 생성하기 위한 인터페이스를 정의하여 어떤 크랠스가 인스턴스화 될 것인지는 서브 클래스가 결정하도록 한다.
Virtual-Constructor 패턴이라고도 한다.

Prototype
-원본 객체를 복제하여 객체를 생성하는 패턴

Singleton
-전역 변수를 사용하지 않고 객체를 하나만 생성하도록 한다.
생성된 객체를 어디서든 참조할 수 있도록 하는 패턴
```

2. 구조 패턴
```
클래스나 객체를 조합해 더 큰 구조를 만드는 패턴

Adapter 
-호환성 없는 인터페이스 때문에 함께 사용할수 없는 클래스를 개조하여 함께 작동할 수 있도록 해주는 패턴

Bridge
- 기능 클래스 계층과 수현 클래스 계층 연결,
구현부에서 추상 계층을 분리하여 각자 독립적으로 변형할 수 있도록 해주는 패턴

Composite
- 여러 개의 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴

Decorator
- 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴

Facade
-'건물의 정면'이라는 의미
클래스 간의 의존관계가 줄고 복잡성이 낮아진다.

Flyweight
-인스턴스를 매번 생성하지않고 가능하다면 공유해 메모리를 절약하는 패턴

Proxy
- 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 어려운 객체와 연결하려는 다른 객체와 인터페이스 임무를 수행하는 패턴
```

3. 행위 패턴 
```
반복적으로 사용되는 객체들의 상호작용을 패턴화한 것
클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의

Chain of Responsibility(책임 연쇄)
- 요청을 처리할 기회를 하나 이상의 객체에 부여함으로 요청하는 객체와 처리하는 객체 사이의 결합도를 없애려는 것

Command
-요청을 객체로 캡슐화하여 서로 다른 요청으로 클라이언트를 마라미터화,
요청을 저장하거나 기록을 남겨 오퍼레이션의 취소도 가능

Interpreter
- 언어에 따라서 문법에 대한 표현을 정의

Iterator(반복자)
- 내부 표현 방법을 노출하지 않고 복합 객체의 원소를 순차적으로 접근할 수 있는 방법 제공

Mediator(중재자)
- 객체 간의 상호작용을 객체로 캡슐화한다.

Memento
- 캡슐화를 위배하지 않고 객체 내부 상태를 객체화하여 나중에 객체가 이 상태로 복구 가능하게 한다.

Observer
- 객체 사이의 일대다 종속성을 정의, 한 객체의 상태가 변하면 종속된 다른 객체에 통보가 가고 자동으로 수정이 일어남

State 
- 객체의 내부 상태에 따라 행위를 변경할 수 있게 한다. 이렇게 하면 객체는 마치 클래스를 바꾸는 것처럼 보인다.

Strategy
- 알고리즘군이 존재할 경우 각각의 알고리즘을 별도의 클래스로 캡슐화하고 이들을 상호교환 가능한 것으로 정의한다.
클라이언트에 영향을 주지 않고 독립적으로 알고맂므을 다양하게 변경할 수 있게 한다

Template method
- 오퍼레이션에는 알고리즘의 처리 과정만을 정의하고 각 단계에서 수행할 구체적 처리는 서브 클래스에 정의한다.
알고리즘 처리과정은 변하지 않고 알고리즘이 각 단계의 처리를 서브 클래스에서 재정의할 수 있게 한다.

Visitor
- 객체 구조의 요소들에 수행할 오퍼레이션을 표현한 패턴이다.
```